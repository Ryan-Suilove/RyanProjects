# **rebase/reset在实际工作中的一些常见运用：**

## 一．**rebase:**

### 定义：

变基。将整个分支，使他们看起来没有经过分叉

*git rebase <upstream> <branch>*

意为将branch的提交移动到upstream后。

### **用法1：使用 rebase 同步主分支更新**

自己分支落后于main分支时，可以先进行rebase，使本地分支基于main最新的内容进行开发。



此刻提交历史如下：


```
A---B---C---D(main)
         \
          E---F (a)
```


如上，此时若（在a分支上）应用*git rebase master*,分支将会变成：


```
A---B---C---D---E`---F` (a)
        |
      (main)
```


rebase中遇到冲突是正常的，根据需要手动处理并add即可标记为解决，VSCode的图形化界面可以很方便完成这一点，解决后进行 *git rebase --continue* 即可，后续相同处理不再赘述。此时main分支的头部依然在C，但切换到main分支后，将可以快速的 *git merge a* 完成将a分支更改合并进main的操作。


```
A---B---C---D`---E` (a)(main)
```


对比：若用merge直接完成上述操作，（在main分支上）应用 *git merge a* ，则提交历史为：


```
A---B---C---D---G(main)
         \     /
          E---F (a)
```


显然，此刻G对应的文件快照和E`对应的文件快照是相同的。但会多出来commit G。

rebase的好处在于使提交历史变得线性清晰，但缺点在于它改变了提交时的哈希（掩盖了真实发生的事情）。因为变基的本质是丢弃一些提交，而新建一些内容上相同但实际上不同的提交在你指定的位置，所以**若有人可能基于你的提交进行开发，请不要变基**，否则可能会导致其他人pull下来你已经丢弃的那些内容造成混乱。



### **用法2：使用交互式 rebase 修改历史提交**

在某分支上提交了若干commit，但发现某些地方有错误。最简单直接的方法是直接修改，走add-commit的流程，但这样会产生新的commit。

想在不提交新commit的情况下改正错误，这同样是一种修改历史的行为（假装一开始提交的内容就是完全正确的），因此可以利用rebase。理论来说修改最近一次提交也可以用 *git commit --ammend* 指令，但掌握git rebase -i 可以应对所有情况。

git rebase -i意为交互式变基（interactive rebase），公式为：

*git rebase -i <base>*

<base>是一个提交的哈希或者分支名

① 如现在想要更改最近的x个commit，可运行 *git rebase -i HEAD~x* ，之后会弹出交互式界面如下，在该界面中可以根据需要进行方便交互。
```
pick a1b2c3d 修复登录逻辑

pick d4e5f6g 优化登录UI

pick h7i8j9k 添加登录单元测试

.

.
```


将pick修改为所需指令，保存关闭即可进入编辑状态。

如果没有弹出交互页面，可全局设置vscode为git处理器   
*git config --global core.editor "code --wait"*

常用指令有**edit**（编辑内容）、**drop**（丢弃该commit以及其对应的修改）、**reword**（修改提交的文本说明）、**squash**（与该标记上面的commit合并，如果两个commit不挨着剪切粘贴调整位置即可）

修改完成后进行add并 *git rebase --continue* 即可，若想回到最初可用 *git rebase --abort*

② 若base处填写分支名，例如在下图所示情况（于分支b上）运行 *git rebase -i a*


```
A---B---C(a)
         \
          D---E(b)
```


则依然会出现D和E的交互式界面，类似情况①


```
pick D 修复登录逻辑

pick E 优化登录UI
```


不同的是在对它们进行完编辑操作后，会同时完成rebase操作，将更改完的commit连接在C上：


```
A---B---C---D`---E` (b)
```


在进行完上述操作后，若已将分支提交到远程过，则应使用 *git push <远程名> <分支名> --force* 使远程的历史与本地同步，同用法1，该情况可能导致冲突，对于团队都使用的分支应谨慎。



### **用法1和2的延申：上游分支变基后的下游同步**

一个常见的情景：在a分支进行工作提交了数个commit，并push到了远端但未合并。在a分支基础上新开了b分支要继续工作，并提交了数个commit。这时评审发现a分支上有错误需要修改，此刻要回到a分支上修改完错误并提交，再回到b分支上进行开发。这种上游分支变基后的下游同步问题，可在依赖分支上使用 rebase

发现错误前，提交历史如下所示：


```
A---B---C(a)
         \
          D---E(b)
```
返回a分支，参照用法2修改提交，并推到远端，此时提交历史如下（以修改了B作例子，C虽然没有修改，但是其哈希已经改变）：


```
     B`---C`(a)
    /    
A---B---C
         \
          D---E(b)
```


此刻b仍然基于a的旧分支，因此应调用git rebase a将b挪到a的现有分支上，这一改动势必会因为修改了历史而冲突，手动处理走add-continue流程即可。

此时提交历史已变成：


```
A---B`---C`(a)
          \
           D`---E`(b)
```

在合并时可以快速先将b合进a，再将a再合进main，b上如果有其他分支也是同理。



### **用法3：使用 rebase --onto 在不同分支间迁移提交**

如下所示，若想在不合并b的前提下，把c分支的更新合并入a，也可以用rebase


```
A---B---C---H(a)
         \
          D---E(b)
           \
            F---G(c)

```

*git rebase --onto a b c* 的含义为从c分支上找出与b分歧后的新增commit，并将其放到a后边。处理完的分支如下：


```
A---B---C---H(a)---F---G(c)
         \
          D---E(b)
```


处理完冲突后可以快速将c分支merge进a，即：


```
A---B---C---H---F---G(c,a)
         \
          D---E(b)
```






## 二．**reset：**

### 定义：重置。

*git reset commit file*


由于git reset 后接HEAD、分支或文件名有不同的用法，中间还可以用双横线加修饰语，因此在情景中更好理解。

### **用法1：git reset 的三种基本模式**

在开始前应理解下面这三棵树的概念，树在这里理解成文件集合较合适：

HEAD：当前分支的指针，通常指向该分支最后一次提交的快照。

Index：暂存区，预期的下次提交快照，

Working Directory：工作区

**一个典型的工作过程：**
```
在工作区完成修改，利用add，可以将文件从工作区提交到暂存区，利用commit将文件从暂存区提交上分支，HEAD将会指向该文件。

此时三棵树完全相同。

继续在工作区修改，文件发生变化（步骤1），再次利用add使暂存区与工作区同步（步骤2），再次利用commit使HEAD和暂存区同步，三棵树再次相同（步骤3）。

……
```
reset的作用就是，可以让三棵树回到某个彼此不同的时刻。

*git reset --soft HEAD~* 对步骤3进行逆操作，使HEAD指向上一次提交，而使暂存区和工作区两棵树不变。（波浪线~代表上一次，也可以用HEAD~2来回到上二次，如果没有波浪线就代表HEAD不变）

*git reset --\[mixed] HEAD~* 括号因为它是默认模式，在步骤3的基础上再进一步，对步骤2也进行逆操作，使暂存区和HEAD都回到前一次提交状态而工作区不变

*git reset --hard HEAD~* 完全回到上次提交的状态，步骤123全部逆转，三颗树再次相同。



### **用法2：git reset 在文件级别的应用**

*git reset file.py* 等价于 *git reset --mixed HEAD file.py*

可以看作 *git add file.py* 的逆。

它与 *git reset --\[mixed] HEAD~* 不同之处在于，它不是在步骤3的基础上的，因此不会移动HEAD指针，而是直接让暂存区和HEAD两棵树变成一样，相当于单独进行了步骤2的逆操作。

因此，可以利用这一特性从远处的某一版本拉去文件到暂存区。例如：

*git reset eb43 file.py* 

从视觉效果来看，HEAD指针和工作区文件都没有动，而是把某个提交哈希为eb43（eb43只是截取了前几位，不用将冗长的哈希全部写出来，只要能唯一辨识即可）的文件拉回到了暂存区里。

如果想进一步使其从暂存区回到工作区，可以使用*git checkout --file.py*



### **用法3：使用 git reset 移动分支指针与压缩提交**

在了解了 git reset 的基本原理和文件级用法后，我们还可以利用它在分支层面进行操作。git reset 不仅可以回退暂存区或工作区的状态，还可以直接移动分支指针，从而改变当前分支所指向的提交。这一特性常用于将分支回退到指定提交，或配合 --soft 选项实现对多次提交的压缩与整理。

如图，若此刻在b分支上运用 *git reset a*


```
A---B---C(a)
         \
          E---F(b)
```


b分支将会指向a分支所在的commit C


```
A---B---C(a,b)
```


利用 *git reset --soft HEAD~x* 可以方便的移动HEAD指针，从而将commit压缩。

例如，我已经提交了三次commit，而第二次commit是冗余的中间版本，则可方便的利用 *git reset --soft HEAD~2* 和 *git commit* 将中间的提交挤掉。



by 李添翼

2025.10.28第一次更新

2025.10.29第二次更新，更新了小节标题及部分语言表述，更新了markdown版本













